---
alwaysApply: true
---


# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Next.js 16 CMS application built with Bun, featuring authentication, database integration, and a modern admin dashboard interface. It uses a **schema-driven architecture** with TypeScript, Tailwind CSS, and modern React patterns for maximum type safety and developer productivity.

## Common Development Commands

**Note: This project uses Bun as the package manager. Use `bun` instead of `npm` for all commands.**

### Development
```bash
bun dev          # Start development server on localhost:3000
bun run build    # Build production application
bun start        # Start production server
bun run lint     # Run ESLint
```

### Database Operations (Drizzle ORM)
```bash
bun run db:generate  # Generate database migrations
bun run db:migrate   # Run database migrations
bun run db:studio    # Open Drizzle Studio for database management
```

## Architecture Principles

### üéØ Core Design Philosophy
This project follows a **schema-driven architecture** with the following principles:
1. **Single Source of Truth**: Database schema drives all types and validation
2. **No Manual Boilerplate**: Auto-generated types and validation from schema
3. **URL-First State**: All filter/search/sort state persists in URLs
4. **Server Actions Only**: Internal data operations use server actions, not API routes
5. **Zero Runtime Type Errors**: Compile-time and runtime type safety from single source

### üèóÔ∏è Directory Structure
- `app/` - Next.js App Router pages (no API routes for internal data)
- `actions/` - Server actions for all data operations
- `configs/` - Filter and feature configurations
- `components/` - React components (UI, forms, feature-specific)
- `server/` - Backend code (auth, database, schemas)
- `lib/` - Shared utilities and validation helpers
- `hooks/` - Custom React hooks for reusable logic

### üîß Key Technologies
- **Package Manager**: Bun
- **Frontend**: Next.js 16, React 19, TypeScript
- **UI Components**: Shadcn/ui with Radix UI primitives
- **Database**: PostgreSQL + Drizzle ORM + Drizzle Zod
- **Authentication**: Better Auth with email/password
- **Icons**: Lucide React and Tabler Icons
- **Styling**: Tailwind CSS v4
- **Forms**: React Hook Form + Drizzle Zod (single source of truth)
- **State Management**: React Hook Form + useQueryFilters + nuqs + TanStack Query
- **Notifications**: Sonner for toast messages
- **URL State**: nuqs for automatic URL synchronization

### Database Setup
- Uses PostgreSQL via Neon serverless
- Database configuration in `drizzle.config.ts`
- **Schemas** with auto-generated Zod validation in `server/db/schema/`
- Database connection in `server/db/connection.ts`
- Migrations output to `server/db/drizzle/`
- **Schema-driven validation** using Drizzle Zod

#### Schema-Driven Validation
```typescript
// Auto-generated from database schema
export const userSelectSchema = createSelectSchema(user)
export const userInsertSchema = createInsertSchema(user)

// Enhanced schemas with custom validation
export const createUserSchema = userInsertSchema
  .pick({ name: true, email: true, image: true })
  .extend({
    name: z.string().min(1, "Name is required"),
    email: z.string().email("Invalid email address"),
    image: z.string().url("Invalid URL").optional().or(z.literal("")),
  })
```

### Authentication
- Better Auth integrated with Next.js API routes
- Auth configuration in `server/auth.ts`
- API handler at `app/api/auth/[...all]/route.ts`
- Uses Drizzle adapter for PostgreSQL
- Email/password authentication enabled

### Custom Components

#### Form System (`components/form/`)
Compound form component pattern with shared state:
- `Form.Input` - Text, email, password inputs with validation
- `Form.Textarea` - Multi-line text inputs
- `Form.Select` - Dropdown selections
- `Form.Checkbox` - Boolean inputs
- `Form.Upload` - File uploads with drag-and-drop support

Usage:
```tsx
const form = useForm<FormData>(initialValues, schema)

<Form form={form} onSubmit={handleSubmit}>
  <Form.Input name="name" label="Name" required />
  <Form.Input name="email" type="email" label="Email" required />
  <Button type="submit">Submit</Button>
</Form>
```

#### Filter System (`components/filters/`)
Reusable filter components with automatic URL state management:
- `FilterBar` - Dynamic filter interface with search, selects, and boolean filters
- `Pagination` - Configurable pagination with page size options
- `SortSelector` - Dropdown sorting control with direction toggle

Usage:
```tsx
const filters = useQueryFilters(usersFilterConfig)

<FilterBar filters={filters} />
<Pagination
  currentPage={filters.currentPage}
  totalPages={totalPages}
  onPageChange={filters.setPage}
  pageSize={filters.pageSize}
  onPageSizeChange={filters.setPageSize}
/>
<SortSelector
  currentSortField={filters.currentSortField}
  sortOptions={config.sorting}
  onSortChange={filters.setSorting}
/>
```

#### Data Table (`components/ui/data-table-v2.tsx`)
Advanced table component with URL state persistence using nuqs:
- Column sorting and filtering
- Global search functionality
- Pagination with configurable page sizes
- Column visibility toggles
- State persisted in URL parameters

Features:
- Automatic state persistence in URL
- Server-side pagination support
- Custom column definitions
- Built-in search and filter UI
- Responsive design

### User Management System
Complete user management implementation at `/app/dashboard/users/`:
- **User CRUD operations** via **Server Actions** (no API routes)
- Reusable form components for user creation/editing with **Drizzle Zod validation**
- Advanced data table with **useQueryFilters** for automatic URL state management
- Real-time updates with toast notifications via **TanStack Query**
- Profile image support
- Accessible through the dashboard sidebar navigation

### Dashboard Structure
The application uses a nested dashboard structure:
- `/dashboard` - Main dashboard page with analytics and overview
- `/dashboard/users` - User management interface
- All dashboard routes share the same sidebar navigation and layout

### UI Components
- Extensive set of reusable UI components in `components/ui/`
- Built on Radix UI primitives with Tailwind CSS
- Consistent design system with proper accessibility
- Includes data tables, charts, forms, navigation components
- Custom compound components for complex interactions

### Dashboard Layout
- Modern admin dashboard with responsive sidebar navigation
- Uses CSS custom properties for layout dimensions
- Chart components with Recharts integration
- Site header with user profile integration

## Path Aliases
- `@/*` maps to root directory for clean imports
- Configuration in `tsconfig.json`

## State Management
- Form state managed by React Hook Form with compound pattern
- Table state persisted in URL using nuqs
- Component state using React hooks
- No external state management library required

## Environment Variables
Required environment variables:
- `DATABASE_URL` - PostgreSQL connection string
- Additional Better Auth configuration variables as needed

## Development Notes
- Uses App Router exclusively
- Server components for data fetching
- Client components marked with `"use client"`
- Modern React patterns with hooks and context
- Comprehensive TypeScript configuration with strict mode
- ESLint for code quality
- Component-first architecture with reusability in mind

## üöÄ Development Rules & Patterns

### ‚ùå What NOT to Do
- **DO NOT** create API routes for internal data operations
- **DO NOT** write manual validation schemas (use Drizzle Zod)
- **DO NOT** manually manage form state (use useQueryFilters + React Hook Form)
- **DO NOT** duplicate type definitions (infer from database schema)
- **DO NOT** ignore URL state persistence

### ‚úÖ What TO DO
- **Always** create server actions for data operations
- **Always** use Drizzle Zod for validation (single source of truth)
- **Always** use `useQueryFilters` for URL state management
- **Always** infer types from database schema
- **Always** persist filter/search/sort state in URLs

## üìã New Feature Template

Adding new features is now dramatically simpler. Here's the complete template:

### 1. Define Database Schema (`server/db/schema/[feature].ts`)
```typescript
import { pgTable, text, timestamp, boolean } from "drizzle-orm/pg-core"
import { createSelectSchema, createInsertSchema } from "drizzle-zod"

export const post = pgTable("post", {
  id: text("id").primaryKey(),
  title: text("title").notNull(),
  content: text("content").notNull(),
  slug: text("slug").notNull().unique(),
  published: boolean("published").default(false),
  authorId: text("author_id").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().$onUpdate(() => new Date()).notNull(),
})

// Auto-generated Zod schemas
export const postSelectSchema = createSelectSchema(post)
export const postInsertSchema = createInsertSchema(post)

// Enhanced validation schemas
export const createPostSchema = postInsertSchema
  .pick({ title: true, content: true, slug: true, published: true, authorId: true })
  .extend({
    title: z.string().min(1, "Title is required"),
    content: z.string().min(10, "Content must be at least 10 characters"),
    slug: z.string().regex(/^[a-z0-9]+(?:-[a-z0-9]+)*$/, "Slug must be URL-friendly"),
    published: z.boolean(),
    authorId: z.string().min(1, "Author is required"),
  })
```

### 2. Create Filter Configuration (`configs/[feature]Filters.ts`)
```typescript
import type { FilterConfig } from "@/hooks/useQueryFilters"
import type { Post } from "@/server/db/schema"

export type PostFilters = {
  search?: string
  published?: boolean
  authorId?: string
}

export const postFilterConfig: FilterConfig<PostFilters> = {
  filters: {
    search: {
      type: 'search',
      label: 'Search',
      placeholder: 'Search posts by title or content...'
    },
    published: {
      type: 'select',
      label: 'Status',
      options: [
        { value: 'all', label: 'All Posts' },
        { value: 'true', label: 'Published' },
        { value: 'false', label: 'Drafts' }
      ],
      defaultValue: 'all'
    }
  },
  sorting: {
    title: { label: 'Title', field: 'title' },
    createdAt: { label: 'Created Date', field: 'createdAt' },
    updatedAt: { label: 'Updated Date', field: 'updatedAt' },
  },
  pagination: {
    defaultPageSize: 10,
    pageSizes: [10, 25, 50]
  }
}
```

### 3. Create Server Actions (`actions/[feature].ts`)
```typescript
"use server"

import { db } from "@/server/db/connection"
import { post, createPostSchema } from "@/server/db/schema"
import { eq, desc, like, or, and } from "drizzle-orm"
import { revalidatePath } from "next/cache"

export async function createPost(formData: FormData) {
  try {
    const rawData = {
      title: formData.get('title'),
      content: formData.get('content'),
      slug: formData.get('slug'),
      published: formData.get('published') === 'true',
      authorId: formData.get('authorId'),
    }

    const { title, content, slug, published, authorId } = createPostSchema.parse(rawData)

    // Auto-generated ID and timestamps
    const newPost = await db.insert(post).values({
      id: `post_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      title,
      content,
      slug,
      published,
      authorId,
    }).returning()

    revalidatePath('/dashboard/posts')

    return {
      success: true,
      data: newPost[0]
    }
  } catch (error) {
    console.error('Error creating post:', error)
    return {
      success: false,
      error: 'Failed to create post'
    }
  }
}

export async function getPosts(params: any = {}) {
  // Auto-generated query schema and validation
  // (similar to users.ts)
  const validatedParams = usersQuerySchema.parse(params)
  const { page, pageSize, search, sortField, sortDirection, published } = validatedParams

  // Database query logic...
  return { data: posts, pagination }
}
```

### 4. Create Page Component (`app/dashboard/[feature]/page.tsx`)
```typescript
"use client"

import { FilterBar, Pagination, SortSelector } from "@/components/filters"
import { DataTableSkeleton } from "@/components/ui/skeleton"
import { usePosts } from "@/hooks/usePosts"
import { postFilterConfig } from "@/configs/postsFilters"

export default function PostsPage() {
  const {
    posts,
    pagination,
    isLoading,
    filters,
    createPost
  } = usePosts()

  return (
    <div className="space-y-6">
      {/* Header with Filters */}
      <div className="flex justify-between items-center">
        <FilterBar filters={filters} />
        <Button onClick={() => {/* Open create dialog */}}>
          Create Post
        </Button>
      </div>

      {/* Sort Controls */}
      <div className="flex justify-between items-center">
        <SortSelector
          currentSortField={filters.currentSortField}
          sortOptions={filters.config.sorting}
          onSortChange={filters.setSorting}
        />
      </div>

      {/* Posts Table */}
      {isLoading ? (
        <DataTableSkeleton />
      ) : (
        <DataTable
          data={posts}
          columns={postColumns}
          onEdit={(post) => {/* Edit logic */}}
          onDelete={(postId) => {/* Delete logic */}}
        />
      )}

      {/* Pagination */}
      <Pagination
        currentPage={filters.currentPage}
        totalPages={pagination.totalPages}
        pageSize={filters.pageSize}
        total={pagination.total}
        onPageChange={filters.setPage}
        onPageSizeChange={filters.setPageSize}
      />
    </div>
  )
}
```

### 5. Update Navigation (`components/app-sidebar.tsx`)
```typescript
// Add to navMain array:
{
  title: "Posts",
  url: "/dashboard/posts",
  icon: IconFileText,
},
```

### 6. Export Schemas (`server/db/schema/index.ts`)
```typescript
// Add to existing exports:
export {
  postSelectSchema,
  postInsertSchema,
  createPostSchema,
  // ... other schemas
} from "./posts";
```

**üéâ That's it!** Your new feature is complete with:
- ‚úÖ **Zero boilerplate** validation
- ‚úÖ **Automatic URL state persistence**
- ‚úÖ **Type-safe** operations
- ‚úÖ **Consistent** patterns with existing code

## üîß Development Guidelines

### State Management Rules
1. **URL-First**: Always persist filter, search, and sort state in URLs using `useQueryFilters`
2. **Form State**: Use React Hook Form with `useForm()` compound pattern
3. **Data Fetching**: Use server actions with TanStack Query for optimal caching
4. **Validation**: Always use Drizzle Zod schemas (single source of truth)

### Component Rules
1. **Compound Components**: Use compound pattern for forms (`Form.Input`, `Form.Upload`, etc.)
2. **Reusability**: Create feature-specific folders in `/components/[feature]/`
3. **Props**: Use TypeScript interfaces with proper type inference
4. **Loading States**: Always provide loading skeletons for better UX

### Database Rules
1. **Schema First**: Always define schema first, then infer types and validation
2. **Timestamps**: Always include `createdAt` and `updatedAt` with automatic updates
3. **IDs**: Use consistent ID patterns like `${prefix}_${timestamp}_${random}`
4. **Relations**: Use Drizzle relations for foreign keys

This architecture makes adding new features **dramatically simpler** and maintains consistency across the entire codebase.